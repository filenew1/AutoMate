# 后端技术栈

本文档定义了AutoMate项目的后端技术栈。

## 1. 技术栈概述

### 1.1 核心技术

| 技术 | 版本 | 说明 |
| :--- | :--- | :--- |
| Node.js | 18.0.0+ | 核心运行环境，用于实现数据库访问、API调用和服务层逻辑 |
| Playwright | 1.36.0+ | 浏览器自动化测试工具，用于智能体的网页操作需求 |

### 1.2 技术选型理由

- **Node.js**：基于Chrome V8引擎的JavaScript运行时，性能优异，生态丰富，适合构建高效的后端服务。作为前端技术的自然延伸，使用JavaScript/TypeScript可以实现前后端代码复用，降低开发成本。
- **Playwright**：功能强大的浏览器自动化工具，支持多种浏览器，提供丰富的API用于网页操作、截图、网络请求拦截等，适合智能体的网页交互需求。

## 2. Node.js

### 2.1 Node.js特性使用

**异步非阻塞I/O：**

```javascript
const fs = require('fs').promises;

async function readConfigFile() {
  try {
    const config = await fs.readFile('./config/agents.json', 'utf8');
    return JSON.parse(config);
  } catch (error) {
    console.error('Error reading config file:', error);
    throw error;
  }
}
```

**模块化设计：**

```javascript
// utils/logger.js
module.exports = {
  info: (message) => console.log(`[INFO] ${new Date().toISOString()} - ${message}`),
  error: (message) => console.error(`[ERROR] ${new Date().toISOString()} - ${message}`),
  debug: (message) => console.debug(`[DEBUG] ${new Date().toISOString()} - ${message}`)
};

// services/agentService.js
const logger = require('../utils/logger');

class AgentService {
  async getAgents() {
    logger.info('Fetching all agents');
    // 实现逻辑
  }
}

module.exports = new AgentService();
```

**事件驱动架构：**

```javascript
const EventEmitter = require('events');

class ChatService extends EventEmitter {
  constructor() {
    super();
  }

  async sendMessage(content, agentId) {
    // 处理消息
    this.emit('messageSent', { content, agentId, timestamp: new Date() });
    return { success: true };
  }
}

module.exports = new ChatService();
```

### 2.2 Node.js最佳实践

- 使用`async/await`处理异步操作，避免回调地狱
- 使用模块化设计，将代码按功能划分为不同的模块
- 使用`try/catch`捕获并处理错误
- 使用环境变量管理配置
- 使用PM2等进程管理器监控应用状态
- 定期更新依赖包，确保安全性

## 3. Playwright

### 3.1 Playwright特性使用

**浏览器自动化：**

```javascript
const { chromium } = require('playwright');

async function scrapeWebpage(url) {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(url);
  const content = await page.content();
  await browser.close();
  return content;
}
```

**表单填写：**

```javascript
const { chromium } = require('playwright');

async function fillForm(url, formData) {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(url);

  for (const [field, value] of Object.entries(formData)) {
    await page.fill(`#${field}`, value);
  }

  await browser.close();
}
```

**网络请求拦截：**

```javascript
const { chromium } = require('playwright');

async function interceptRequests(url) {
  const browser = await chromium.launch();
  const page = await browser.newPage();

  // 拦截网络请求
  await page.route('**/*.json', async (route) => {
    const response = await route.fetch();
    const json = await response.json();
    console.log('Intercepted JSON response:', json);
    await route.continue();
  });

  await page.goto(url);
  await browser.close();
}
```

### 3.2 Playwright最佳实践

- 使用`try/finally`确保浏览器实例正确关闭
- 使用等待机制确保元素加载完成
- 使用选择器策略提高元素定位的可靠性
- 使用截图和视频记录进行调试
- 在生产环境中使用无头浏览器模式
- 合理设置浏览器启动参数，平衡性能和功能

## 4. Node.js核心模块

### 4.1 常用核心模块

**fs - 文件系统：**

```javascript
const fs = require('fs').promises;

async function writeMessageToFile(message, agentId) {
  const filePath = `./data/messages/${agentId}.json`;
  try {
    // 确保目录存在
    await fs.mkdir('./data/messages', { recursive: true });
    
    // 读取现有消息
    let messages = [];
    try {
      const existingData = await fs.readFile(filePath, 'utf8');
      messages = JSON.parse(existingData);
    } catch (error) {
      // 文件不存在，创建新数组
    }
    
    // 添加新消息
    messages.push({
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // 写入文件
    await fs.writeFile(filePath, JSON.stringify(messages, null, 2));
  } catch (error) {
    console.error('Error writing message to file:', error);
    throw error;
  }
}
```

**http/https - 网络请求：**

```javascript
const https = require('https');

function fetchApiData(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (response) => {
      let data = '';
      response.on('data', (chunk) => {
        data += chunk;
      });
      response.on('end', () => {
        resolve(JSON.parse(data));
      });
    }).on('error', (error) => {
      reject(error);
    });
  });
}
```

**path - 路径处理：**

```javascript
const path = require('path');

function getConfigPath() {
  return path.resolve(__dirname, '..', 'config', 'settings.json');
}
```

**os - 操作系统信息：**

```javascript
const os = require('os');

function getSystemInfo() {
  return {
    platform: os.platform(),
    arch: os.arch(),
    memory: os.totalmem(),
    cpus: os.cpus().length
  };
}
```

## 5. 第三方库

### 5.1 核心依赖

**sqlite3 或 better-sqlite3：** SQLite数据库驱动

```javascript
const sqlite3 = require('sqlite3').verbose();

class Database {
  constructor(dbPath) {
    this.db = new sqlite3.Database(dbPath);
    this.init();
  }

  init() {
    // 创建表
    this.db.run(`
      CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        agent_id TEXT NOT NULL,
        content TEXT NOT NULL,
        message_type TEXT NOT NULL,
        send_time DATETIME DEFAULT CURRENT_TIMESTAMP,
        status TEXT DEFAULT 'sent'
      );
    `);
  }

  async insertMessage(agentId, content, messageType) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO messages (agent_id, content, message_type) VALUES (?, ?, ?)',
        [agentId, content, messageType],
        function(err) {
          if (err) reject(err);
          else resolve({ id: this.lastID });
        }
      );
    });
  }
}

module.exports = Database;
```

**express：** 轻量级Web框架（如需提供HTTP API）

```javascript
const express = require('express');
const app = express();

app.use(express.json());

app.post('/api/messages', async (req, res) => {
  try {
    const { agentId, content } = req.body;
    const result = await messageService.sendMessage(agentId, content);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

**dotenv：** 环境变量管理

```javascript
require('dotenv').config();

const apiKey = process.env.API_KEY;
const dbPath = process.env.DB_PATH || './data/automate.db';
```

**winston：** 日志管理

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

logger.info('Application started');
logger.error('An error occurred');
```

## 6. 项目结构

### 6.1 后端目录结构

```
backend/
├── api/                # API路由（如需提供HTTP API）
│   ├── agents.js       # 智能体API
│   ├── messages.js     # 消息API
│   └── skills.js       # 技能API
├── services/           # 业务逻辑
│   ├── agentService.js
│   ├── chatService.js
│   └── skillService.js
├── models/             # 数据模型
│   ├── agent.js
│   └── message.js
├── utils/              # 工具函数
│   ├── logger.js
│   ├── encryption.js
│   └── fileHandler.js
├── config/             # 配置文件
│   ├── settings.js
│   └── database.js
├── data/               # 数据存储
│   └── automate.db     # SQLite数据库文件
├── main.js             # 应用入口
└── package.json        # 依赖配置
```

## 7. 参考资源

- [Node.js官方文档](https://nodejs.org/docs/latest-v18.x/api/)
- [Playwright官方文档](https://playwright.dev/docs/intro)
- [SQLite官方文档](https://www.sqlite.org/docs.html)
- [Express官方文档](https://expressjs.com/)
- [Node.js最佳实践](https://github.com/goldbergyoni/nodebestpractices)