# 前端技术栈

本文档定义了AutoMate项目的前端技术栈。

## 1. 技术栈概述

### 1.1 核心技术

| 分类 | 技术选型 | 核心用途 | 
| :--- | :--- | :--- | 
| **基础架构** | **Tauri 2.x** | 桌面框架、Rust 后端、打包成 exe/deb | 
| **前端构建** | **Vite** | 极速的开发服务器和打包工具 | 
| **核心框架** | **React 18+** | UI 开发 | 
| **语言** | **TypeScript** | 类型安全 | 
| **样式方案** | **Tailwind CSS** | 原子化 CSS，快速还原 UI | 
| **组件库** | **Radix UI** | 提供无样式的复杂交互逻辑（弹窗、菜单） | 
| **图标** | **Lucide React** | 矢量图标 | 
| **状态管理** | **Zustand** | 轻量级全局状态（聊天记录、设置） | 
| **路由** | **React Router** | 页面视图切换 | 
| **Markdown** | **react-markdown** | 渲染 AI 的回复内容 | 
| **文件操作** | **@tauri-apps/plugin-fs** | **关键**：读写本地文件 | 
| **系统对话框**| **@tauri-apps/plugin-dialog** | **关键**：原生文件选择/保存窗口 | 
| **网络请求** | **Axios** | 调用 AI 接口或本地 API |

### 1.2 技术选型理由

- **Tauri 2.x**：轻量级桌面应用框架，使用Rust后端提供更好的性能和安全性，支持多平台打包
- **React 18+**：提供类型安全的组件化开发，适合构建复杂的用户界面
- **TypeScript**：提供类型安全，定义完整的接口类型和联合类型
- **Tailwind CSS**：原子化CSS，快速还原UI设计，减少CSS代码量
- **Vite**：极速的开发服务器和打包工具，提供更好的开发体验
- **Radix UI**：提供无样式的复杂交互逻辑，便于自定义样式
- **Lucide React**：轻量级矢量图标库，提供丰富的图标选择
- **Zustand**：轻量级全局状态管理，适合管理聊天记录和应用设置
- **React Router**：实现单页应用路由管理，支持页面视图切换
- **react-markdown**：渲染AI的Markdown格式回复内容
- **@tauri-apps/plugin-fs**：提供本地文件系统操作能力，是桌面应用的关键功能
- **@tauri-apps/plugin-dialog**：提供原生文件选择/保存窗口，提升用户体验
- **Axios**：简洁易用的网络请求库，用于调用AI接口或本地API

## 2. React

### 2.1 React 18+特性使用

**Hooks API：**

```tsx
import React, { useState, useEffect } from 'react';

interface Message {
  id: string;
  content: string;
}

const MessageList: React.FC<{ agentId: string }> = ({ agentId }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchMessages = async () => {
      setLoading(true);
      // 模拟获取消息
      const response = await fetch(`/api/messages?agentId=${agentId}`);
      const data = await response.json();
      setMessages(data);
      setLoading(false);
    };

    fetchMessages();
  }, [agentId]);

  if (loading) return <div>Loading messages...</div>;

  return (
    <div className="message-list">
      {messages.map(message => (
        <div key={message.id} className="message">
          {message.content}
        </div>
      ))}
    </div>
  );
};
```

**React 18并发特性：**

```tsx
import React, { useState, useTransition } from 'react';

const ChatInterface: React.FC = () => {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<string[]>([]);
  const [isPending, startTransition] = useTransition();

  const handleSend = () => {
    // 使用startTransition标记非紧急更新
    startTransition(() => {
      setMessages(prev => [...prev, input]);
    });
    setInput('');
  };

  return (
    <div className="chat-interface">
      <div className="messages">
        {messages.map((msg, index) => (
          <div key={index}>{msg}</div>
        ))}
      </div>
      <div className="input-area">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
        />
        <button onClick={handleSend} disabled={isPending}>
          {isPending ? 'Sending...' : 'Send'}
        </button>
      </div>
    </div>
  );
};
```

**自定义Hooks：**

```tsx
import { useState, useCallback } from 'react';

interface UseLocalStorageOptions<T> {
  defaultValue: T;
}

function useLocalStorage<T>(
  key: string,
  { defaultValue }: UseLocalStorageOptions<T>
): [T, (value: T) => void] {
  const [value, setValue] = useState<T>(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : defaultValue;
  });

  const setStoredValue = useCallback((newValue: T) => {
    setValue(newValue);
    localStorage.setItem(key, JSON.stringify(newValue));
  }, [key]);

  return [value, setStoredValue];
}

// 使用示例
const [settings, setSettings] = useLocalStorage('appSettings', {
  theme: 'dark',
  fontSize: 16,
});
```

### 2.2 React 18+最佳实践

- 优先使用函数组件和Hooks
- 使用useCallback和useMemo优化性能
- 合理使用useEffect处理副作用
- 使用React 18的并发特性（useTransition、useDeferredValue）提升用户体验
- 使用TypeScript确保类型安全
- 组件拆分遵循单一职责原则
- 使用React.memo避免不必要的重渲染
- 合理使用Context API管理全局状态（或使用Zustand）

## 3. TypeScript

### 3.1 TypeScript特性使用

**类型定义：**

```typescript
// 接口定义
interface Agent {
  id: string;
  name: string;
  description: string;
}

// 类型别名
type AgentType = 'chat' | 'code' | 'data';

// 联合类型
type AgentOrGroup = Agent | Group;

// 泛型
function identity<T>(arg: T): T {
  return arg;
}
```

**类型注解：**

```typescript
// 函数参数和返回值类型注解
function sendMessage(content: string, agentId: string): Promise<Message> {
  // 函数实现
  return message;
}

// 变量类型注解
const agents: Agent[] = [];
```

**类型守卫：**

```typescript
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: unknown) {
  if (isString(value)) {
    console.log(value.toUpperCase());
  }
}
```

### 3.2 TypeScript最佳实践

- 配置严格模式确保类型正确性
- 使用接口定义对象类型
- 使用类型别名定义联合类型、交叉类型等
- 使用泛型提高代码复用性
- 避免使用any类型

## 4. Tailwind CSS

### 4.1 Tailwind CSS配置

**配置文件：**

```javascript
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#3b82f6',
        secondary: '#8b5cf6',
      },
    },
  },
  plugins: [],
};
```

**自定义主题：**

```javascript
// 深色模式支持
module.exports = {
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        dark: {
          bg: '#111827',
          text: '#f9fafb',
        },
      },
    },
  },
};
```

### 4.2 Tailwind CSS最佳实践

- 使用@apply指令封装常用样式
- 配置响应式断点
- 使用深色模式支持
- 避免在JS中动态生成类名

## 5. Vite

### 5.1 Vite配置

**配置文件：**

```javascript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
  },
});
```

### 5.2 Vite最佳实践

- 使用ES模块按需加载
- 配置开发服务器代理
- 配置构建优化策略（代码分割、tree-shaking）
- 使用环境变量管理不同环境的配置

## 6. React Router

### 6.1 路由配置

**路由定义：**

```tsx
// App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<WelcomePage />} />
        <Route path="/chat/:agentId" element={<ChatPage />} />
        <Route path="/settings" element={<SettingsPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

**嵌套路由：**

```tsx
// 嵌套路由
<Routes>
  <Route path="/chat/:agentId" element={<ChatLayout />}>
    <Route index element={<ChatWindow />} />
    <Route path="settings" element={<ChatSettings />} />
  </Route>
</Routes>
```

### 6.2 React Router最佳实践

- 使用嵌套路由组织复杂页面
- 使用路由守卫保护需要认证的路由
- 使用路由参数传递数据
- 使用编程式导航处理特殊逻辑

## 7. 参考资源

- [React官方文档](https://react.dev/)
- [TypeScript官方文档](https://www.typescriptlang.org/docs/)
- [Tailwind CSS文档](https://tailwindcss.com/docs)
- [Vite官方文档](https://vitejs.dev/)
- [React Router文档](https://reactrouter.com/)
- [Tauri官方文档](https://tauri.app/)
- [Radix UI文档](https://www.radix-ui.com/)
- [Lucide React文档](https://lucide.dev/)
- [Zustand文档](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [react-markdown文档](https://github.com/remarkjs/react-markdown)
- [Axios文档](https://axios-http.com/docs/intro)
