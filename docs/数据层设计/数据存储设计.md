# 数据存储设计

本文档定义了AutoMate项目的数据存储设计，包括本地存储、文件存储、加密存储等。

## 1. 存储概述

### 1.1 存储架构

AutoMate采用多层存储架构：

- **数据库存储**：使用SQLite存储结构化数据（聊天消息、技能调用记录等）
- **文件存储**：使用本地文件系统存储文件附件
- **配置存储**：使用JSON文件存储配置信息
- **本地存储**：使用localStorage存储前端状态

### 1.2 存储路径

| 存储类型 | 路径 | 说明 |
| :--- | :--- | :--- |
| 数据库 | `./data/automate.db` | SQLite数据库文件 |
| 文件附件 | `./data/files/` | 上传的文件附件 |
| 配置文件 | `./config/` | 智能体配置等 |
| 日志文件 | `./logs/` | 应用日志 |
| 临时文件 | `./temp/` | 临时文件 |

### 1.3 存储策略

- **数据本地化**：所有数据存储在本地，不上传云端
- **数据加密**：敏感数据使用AES-256加密存储
- **数据备份**：支持数据备份和恢复
- **数据清理**：定期清理过期数据

## 2. 本地存储

### 2.1 localStorage使用

**存储键命名：**

- 使用前缀区分不同类型的数据
- 示例：`automate.theme`, `automate.sidebar.width`, `automate.lastAgent`

**存储内容：**

```typescript
// 主题设置
localStorage.setItem('automate.theme', 'dark');

// 侧边栏宽度
localStorage.setItem('automate.sidebar.width', '280');

// 最后选中的智能体
localStorage.setItem('automate.lastAgent', JSON.stringify({
  id: 'agent1',
  name: 'Assistant'
}));

// 分组展开状态
localStorage.setItem('automate.groups.expanded', JSON.stringify({
  'group1': true,
  'group2': false
}));
```

**读取数据：**

```typescript
// 读取主题设置
const theme = localStorage.getItem('automate.theme') || 'light';

// 读取侧边栏宽度
const sidebarWidth = parseInt(localStorage.getItem('automate.sidebar.width') || '280');

// 读取最后选中的智能体
const lastAgent = JSON.parse(localStorage.getItem('automate.lastAgent') || 'null');

// 读取分组展开状态
const groupsExpanded = JSON.parse(localStorage.getItem('automate.groups.expanded') || '{}');
```

**删除数据：**

```typescript
// 删除主题设置
localStorage.removeItem('automate.theme');

// 清空所有数据
localStorage.clear();
```

### 2.2 sessionStorage使用

**使用场景：**

- 临时存储会话数据
- 页面刷新后数据清除

**示例：**

```typescript
// 存储会话数据
sessionStorage.setItem('automate.session.id', 'session123');

// 读取会话数据
const sessionId = sessionStorage.getItem('automate.session.id');

// 删除会话数据
sessionStorage.removeItem('automate.session.id');
```

### 2.3 IndexedDB使用

**使用场景：**

- 存储大量结构化数据
- 支持索引查询

**示例：**

```typescript
// 打开数据库
const request = indexedDB.open('AutoMateDB', 1);

request.onupgradeneeded = (event) => {
  const db = (event.target as IDBOpenDBRequest).result;

  // 创建对象存储
  if (!db.objectStoreNames.contains('messages')) {
    const store = db.createObjectStore('messages', { keyPath: 'id' });
    store.createIndex('agentId', 'agent_id', { unique: false });
    store.createIndex('sendTime', 'send_time', { unique: false });
  }
};

request.onsuccess = (event) => {
  const db = (event.target as IDBOpenDBRequest).result;

  // 添加数据
  const transaction = db.transaction(['messages'], 'readwrite');
  const store = transaction.objectStore('messages');
  store.add({
    id: 'msg1',
    agent_id: 'agent1',
    content: 'Hello',
    send_time: new Date()
  });
};
```

## 3. 文件存储

### 3.1 文件存储结构

**目录结构：**

```
./data/files/
├── attachments/          # 消息附件
│   ├── images/         # 图片附件
│   ├── documents/      # 文档附件
│   └── others/         # 其他附件
├── uploads/             # 用户上传的文件
├── temp/               # 临时文件
└── backups/            # 备份文件
```

### 3.2 文件上传流程

**前端上传：**

```typescript
async function uploadFile(file: File): Promise<string> {
  const formData = new FormData();
  formData.append('file', file);

  const response = await fetch('/api/upload', {
    method: 'POST',
    body: formData
  });

  const result = await response.json();
  return result.filePath;
}
```

**后端处理：**

```javascript
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

async function saveUploadedFile(file) {
  const { buffer, originalname, mimetype } = file;

  const fileHash = crypto.createHash('sha256').update(buffer).digest('hex');

  let storageDir;
  if (mimetype.startsWith('image/')) {
    storageDir = path.join('./data/files/attachments/images');
  } else if (mimetype.startsWith('text/')) {
    storageDir = path.join('./data/files/attachments/documents');
  } else {
    storageDir = path.join('./data/files/attachments/others');
  }

  await fs.mkdir(storageDir, { recursive: true });

  const fileExtension = path.extname(originalname);
  const fileName = `${fileHash}${fileExtension}`;
  const filePath = path.join(storageDir, fileName);

  await fs.writeFile(filePath, buffer);

  return filePath;
}
```

### 3.3 文件元数据存储

**文件信息对象：**

```javascript
class FileInfo {
  constructor(fileName, fileType, fileSize, storagePath, fileHash) {
    this.fileName = fileName;
    this.fileType = fileType;
    this.fileSize = fileSize;
    this.storagePath = storagePath;
    this.fileHash = fileHash;
    this.uploadTime = new Date();
  }
}
```

**保存文件元数据：**

```javascript
const Database = require('better-sqlite3');

async function saveFileMetadata(fileInfo, messageId) {
  const db = new Database('database.db');

  const stmt = db.prepare(
    'INSERT INTO file_attachments (message_id, file_name, file_type, file_size, storage_path, file_hash) VALUES (?, ?, ?, ?, ?, ?)'
  );

  stmt.run(
    messageId,
    fileInfo.fileName,
    fileInfo.fileType,
    fileInfo.fileSize,
    fileInfo.storagePath,
    fileInfo.fileHash
  );

  db.close();
}
```

### 3.4 文件下载

**后端接口：**

```javascript
const express = require('express');
const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');

const app = express();

app.get('/api/files/:fileHash', (req, res) => {
  const { fileHash } = req.params;

  const db = new Database('database.db');
  const stmt = db.prepare('SELECT storage_path, file_name FROM file_attachments WHERE file_hash = ?');
  const row = stmt.get(fileHash);
  db.close();

  if (!row) {
    return res.status(404).json({ error: 'File not found' });
  }

  const { storage_path, file_name } = row;

  res.download(storage_path, file_name);
});
```

**前端下载：**

```typescript
async function downloadFile(fileHash: string, fileName: string) {
  const response = await fetch(`/api/files/${fileHash}`);
  const blob = await response.blob();

  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  window.URL.revokeObjectURL(url);
}
```

### 3.5 文件清理

**定期清理临时文件：**

```javascript
const fs = require('fs').promises;
const path = require('path');

async function cleanTempFiles(tempDir, maxAgeHours = 24) {
  const tempPath = path.join(tempDir);
  const currentTime = Date.now();

  const files = await fs.readdir(tempPath);

  for (const file of files) {
    const filePath = path.join(tempPath, file);
    const stats = await fs.stat(filePath);

    if (stats.isFile()) {
      const fileAge = currentTime - stats.mtimeMs;
      if (fileAge > maxAgeHours * 3600 * 1000) {
        await fs.unlink(filePath);
        console.log(`Deleted temporary file: ${filePath}`);
      }
    }
  }
}
```

**清理未引用的文件：**

```javascript
const Database = require('better-sqlite3');
const fs = require('fs').promises;
const path = require('path');

async function cleanOrphanedFiles() {
  const db = new Database('database.db');
  const stmt = db.prepare('SELECT storage_path FROM file_attachments');
  const rows = stmt.all();
  db.close();

  const dbFiles = new Set(rows.map(row => row.storage_path));

  const filesDir = path.join('./data/files/attachments');
  const fsFiles = new Set();

  async function walkDir(dir) {
    const files = await fs.readdir(dir);
    for (const file of files) {
      const filePath = path.join(dir, file);
      const stats = await fs.stat(filePath);
      if (stats.isFile()) {
        fsFiles.add(filePath);
      } else if (stats.isDirectory()) {
        await walkDir(filePath);
      }
    }
  }

  await walkDir(filesDir);

  const orphanedFiles = [...fsFiles].filter(file => !dbFiles.has(file));
  for (const filePath of orphanedFiles) {
    await fs.unlink(filePath);
    console.log(`Deleted orphaned file: ${filePath}`);
  }
}
```

## 4. 加密存储

### 4.1 数据加密

**使用crypto库：**

```javascript
const crypto = require('crypto');

function generateKey(password, salt = null) {
  if (salt === null) {
    salt = crypto.randomBytes(16);
  }

  const key = crypto.pbkdf2Sync(
    password,
    salt,
    100000,
    32,
    'sha256'
  );

  return { key, salt };
}

function encryptData(data, key) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  return {
    iv: iv.toString('hex'),
    encryptedData: encrypted
  };
}

function decryptData(encryptedData, key, iv) {
  const decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(iv, 'hex'));

  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}
```

**加密聊天消息：**

```javascript
const Database = require('better-sqlite3');

function saveEncryptedMessage(content, agentId, encryptionKey) {
  const db = new Database('database.db');
  
  const encrypted = encryptData(content, encryptionKey);
  const encryptedContent = JSON.stringify(encrypted);

  const stmt = db.prepare(
    'INSERT INTO chat_messages (content, agent_id, message_type) VALUES (?, ?, ?)'
  );
  
  stmt.run(encryptedContent, agentId, 'user');
  db.close();
}
```

**解密聊天消息：**

```javascript
function getDecryptedMessages(agentId, encryptionKey) {
  const db = new Database('database.db');
  
  const stmt = db.prepare(
    'SELECT id, content, send_time FROM chat_messages WHERE agent_id = ?'
  );
  const rows = stmt.all(agentId);
  db.close();

  const messages = [];
  for (const row of rows) {
    const encrypted = JSON.parse(row.content);
    const decryptedContent = decryptData(encrypted.encryptedData, encryptionKey, encrypted.iv);
    messages.push({
      id: row.id,
      content: decryptedContent,
      send_time: row.send_time
    });
  }

  return messages;
}
```

### 4.2 文件加密

**加密文件：**

```javascript
const crypto = require('crypto');
const fs = require('fs').promises;

async function encryptFile(inputPath, outputPath, key) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);

  const fileData = await fs.readFile(inputPath);
  let encrypted = cipher.update(fileData);
  encrypted = Buffer.concat([encrypted, cipher.final()]);

  const result = Buffer.concat([iv, encrypted]);
  await fs.writeFile(outputPath, result);
}
```

**解密文件：**

```javascript
const crypto = require('crypto');
const fs = require('fs').promises;

async function decryptFile(inputPath, outputPath, key) {
  const fileData = await fs.readFile(inputPath);

  const iv = fileData.slice(0, 16);
  const encryptedData = fileData.slice(16);

  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
  let decrypted = decipher.update(encryptedData);
  decrypted = Buffer.concat([decrypted, decipher.final()]);

  await fs.writeFile(outputPath, decrypted);
}
```

### 4.3 密钥管理

**密钥存储：**

```javascript
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

const KEY_FILE = './config/encryption.key';

async function saveEncryptionKey(key) {
  const keyPath = path.resolve(KEY_FILE);
  const keyDir = path.dirname(keyPath);

  await fs.mkdir(keyDir, { recursive: true });
  await fs.writeFile(keyPath, key);
}

async function loadEncryptionKey() {
  const keyPath = path.resolve(KEY_FILE);

  try {
    const key = await fs.readFile(keyPath);
    return key;
  } catch (error) {
    throw new Error('Encryption key file not found');
  }
}
```

**密钥生成：**

```javascript
const crypto = require('crypto');

function generateAndSaveKey() {
  const key = crypto.randomBytes(32);
  saveEncryptionKey(key);
  return key;
}
```

## 5. 数据备份和恢复

### 5.1 数据备份

**数据库备份：**

```javascript
const fs = require('fs').promises;
const path = require('path');

async function backupDatabase(dbPath, backupDir = './data/backups') {
  const backupPath = path.resolve(backupDir);
  await fs.mkdir(backupPath, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const backupFile = path.join(backupPath, `automate_${timestamp}.db`);

  await fs.copyFile(dbPath, backupFile);

  console.log(`Database backed up to: ${backupFile}`);
  return backupFile;
}
```

**文件备份：**

```javascript
const fs = require('fs').promises;
const path = require('path');
const archiver = require('archiver');

async function backupFiles(sourceDir, backupDir = './data/backups') {
  const backupPath = path.resolve(backupDir);
  await fs.mkdir(backupPath, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const backupFile = path.join(backupPath, `files_${timestamp}.zip`);

  const output = fs.createWriteStream(backupFile);
  const archive = archiver('zip', { zlib: { level: 9 } });

  return new Promise((resolve, reject) => {
    output.on('close', () => {
      console.log(`Files backed up to: ${backupFile}`);
      resolve(backupFile);
    });

    archive.on('error', (err) => {
      reject(err);
    });

    archive.pipe(output);
    archive.directory(sourceDir, false);
    archive.finalize();
  });
}
```

### 5.2 数据恢复

**数据库恢复：**

```javascript
const fs = require('fs').promises;
const path = require('path');

async function restoreDatabase(backupFile, dbPath) {
  const dbPathResolved = path.resolve(dbPath);

  if (await fs.access(dbPathResolved).then(() => true).catch(() => false)) {
    await fs.copyFile(dbPathResolved, `${dbPathResolved}.backup`);
  }

  await fs.copyFile(backupFile, dbPathResolved);

  console.log(`Database restored from: ${backupFile}`);
}
```

**文件恢复：**

```javascript
const fs = require('fs').promises;
const unzipper = require('unzipper');

async function restoreFiles(backupFile, targetDir) {
  await fs.createReadStream(backupFile)
    .pipe(unzipper.Extract({ path: targetDir }))
    .promise();

  console.log(`Files restored from: ${backupFile}`);
}
```

## 6. 数据清理策略

### 6.1 数据保留策略

**保留期限：**

- 聊天消息：30天
- 技能调用记录：7天
- 文件附件：与关联消息同生命周期
- 临时文件：24小时

### 6.2 自动清理任务

**清理过期数据：**

```javascript
const Database = require('better-sqlite3');

async function cleanExpiredData() {
  const db = new Database('database.db');

  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
  const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();

  const stmt1 = db.prepare('DELETE FROM chat_messages WHERE send_time < ?');
  stmt1.run(thirtyDaysAgo);

  const stmt2 = db.prepare('DELETE FROM skill_calls WHERE call_time < ?');
  stmt2.run(sevenDaysAgo);

  db.close();

  await cleanTempFiles('./data/temp', 24);
  await cleanOrphanedFiles();

  console.log('Expired data cleaned');
}
```

**定时执行清理任务：**

```javascript
const cron = require('node-cron');

function scheduledCleanup() {
  cleanExpiredData();
}

cron.schedule('0 2 * * *', scheduledCleanup);
```

## 7. 存储性能优化

### 7.1 批量操作

**批量插入数据：**

```javascript
const Database = require('better-sqlite3');

function batchInsertMessages(messages) {
  const db = new Database('database.db');
  db.prepare('BEGIN TRANSACTION').run();

  try {
    const stmt = db.prepare(
      'INSERT INTO chat_messages (content, agent_id, message_type) VALUES (?, ?, ?)'
    );

    for (const message of messages) {
      stmt.run(message.content, message.agent_id, message.message_type);
    }

    db.prepare('COMMIT').run();
  } catch (error) {
    db.prepare('ROLLBACK').run();
    throw error;
  } finally {
    db.close();
  }
}
```

### 7.2 缓存策略

**使用缓存：**

```javascript
const crypto = require('crypto');
const fs = require('fs').promises;

const cache = new Map();
const MAX_CACHE_SIZE = 100;

async function getFileHash(filePath) {
  if (cache.has(filePath)) {
    return cache.get(filePath);
  }

  const fileData = await fs.readFile(filePath);
  const hash = crypto.createHash('sha256').update(fileData).digest('hex');

  if (cache.size >= MAX_CACHE_SIZE) {
    const firstKey = cache.keys().next().value;
    cache.delete(firstKey);
  }

  cache.set(filePath, hash);
  return hash;
}
```

## 8. 存储监控

### 8.1 存储空间监控

**检查存储空间：**

```javascript
const fs = require('fs');

function getStorageUsage(directory) {
  const stats = fs.statSync(directory);
  const usage = process.platform === 'win32' 
    ? require('diskusage').sync(directory)
    : require('systeminformation').fsSize(directory);

  return {
    total: usage.total,
    used: usage.used,
    free: usage.free,
    percent: (usage.used / usage.total) * 100
  };
}

function checkStorageSpace(directory, threshold = 90.0) {
  const usage = getStorageUsage(directory);
  if (usage.percent > threshold) {
    console.log(`Warning: Storage usage is ${usage.percent.toFixed(2)}%`);
    return false;
  }
  return true;
}
```

### 8.2 数据库大小监控

**检查数据库大小：**

```javascript
const fs = require('fs');

function getDatabaseSize(dbPath) {
  const stats = fs.statSync(dbPath);
  return stats.size;
}

function checkDatabaseSize(dbPath, maxSize = 100 * 1024 * 1024) {
  const size = getDatabaseSize(dbPath);
  if (size > maxSize) {
    console.log(`Warning: Database size is ${(size / 1024 / 1024).toFixed(2)}MB`);
    return false;
  }
  return true;
}
```

## 9. 参考资源

- [Node.js crypto文档](https://nodejs.org/api/crypto.html)
- [SQLite文档](https://www.sqlite.org/docs.html)
- [Node.js fs文档](https://nodejs.org/api/fs.html)
